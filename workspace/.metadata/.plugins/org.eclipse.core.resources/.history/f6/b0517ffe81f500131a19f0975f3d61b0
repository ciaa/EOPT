/*
===============================================================================
 Name        : main.c
 Author      : $(author)
 Version     :
 Copyright   : $(copyright)
 Description : main definition
===============================================================================
*/

#ifdef __USE_CMSIS
#include "LPC43xx.h"
#endif


#include <cr_section_macros.h>

#include "cr_start_m0.h"

#include "lpc43xx_gpio.h"
#include "lpc43xx_scu.h"
#include "lpc43xx_cgu.h"
#include "lpc43xx_rit.h"
#include "lpc43xx_uart.h"
#include "debug_frmwrk.h"

#include "webserver.h"
#include "tcpip.h"
#include "database.h"

#include "stdio.h"

#include "ciaaUART.h"

volatile uint32_t msec;

uint32_t wiegandTimeout;

#define ciaaDigitalInputs() ((uint8_t)((GPIO_ReadValue(3) & (0x0F<<11))>>7)|(GPIO_ReadValue(2) & 0x0F))

uint32_t ciaaReadInput(uint32_t inputNumber)
{
	if(inputNumber > 7) return ~0;
	return ciaaDigitalInputs() & (1<<inputNumber);
}

#define wiegandData0() (GPIO_ReadValue(3)&(1<<0))
#define wiegandData1() (GPIO_ReadValue(5)&(1<<5))

uint32_t wiegand26(void)
{
	uint32_t word = 0;
	int bit;

	for(bit = 0; bit<26; bit++)
	{
		//Espero por un 0 en Data0 o Data1
		wiegandTimeout = 50;
		while(wiegandData0() && wiegandData1() && wiegandTimeout);

		if(wiegandTimeout==0) return 0;

		//Si el 0 viene por Data1, poner el bit en 1
		if(!wiegandData1())
			word |= 1<<bit;

		//Espero por Data0 y Data1 en cero
		while(!(wiegandData0()&&wiegandData1()));
	}

	return word;
}

void wiegandReaderTask(void)
{
	char uid[20];

	uint32_t word = wiegand26();

	if(word == 0) return;

	sprintf(uid, "%08X", (unsigned int)word);
	dbNewUID(uid);

	dbgPrint("[wiegandReaderTask]Tag leido: ");
	dbgPrint(uid);
	dbgPrint("\n");

}

void ciaaInputInit(void)
{
	scu_pinmux(4,0,MD_PUP|MD_EZI|MD_ZI,FUNC0);	//GPIO2[0]
	scu_pinmux(4,1,MD_PUP|MD_EZI|MD_ZI,FUNC0);	//GPIO2[1]
	scu_pinmux(4,2,MD_PUP|MD_EZI|MD_ZI,FUNC0);	//GPIO2[2]
	scu_pinmux(4,3,MD_PUP|MD_EZI|MD_ZI,FUNC0);	//GPIO2[3]

	scu_pinmux(7,3,MD_PUP|MD_EZI|MD_ZI,FUNC0);	//GPIO3[11]
	scu_pinmux(7,4,MD_PUP|MD_EZI|MD_ZI,FUNC0);	//GPIO3[12]
	scu_pinmux(7,5,MD_PUP|MD_EZI|MD_ZI,FUNC0);	//GPIO3[13]
	scu_pinmux(7,6,MD_PUP|MD_EZI|MD_ZI,FUNC0);	//GPIO3[14]

	scu_pinmux(6,1,MD_PUP|MD_EZI|MD_ZI,FUNC0);	//GPIO0/P6_1/GPIO3[0]
	scu_pinmux(2,5,MD_PUP|MD_EZI|MD_ZI,FUNC4);	//GPIO1/P2_5/GPIO5[5]

	GPIO_SetDir(2,0xF, 0);
	GPIO_SetDir(3, (0xF<<11)|(1<<0), 0);
	GPIO_SetDir(5, (1<<5), 0);

}

void SysTick_Handler (void) 					// SysTick Interrupt Handler @ 1000Hz
{
	static int TimeTick=0;

	if(msec)msec--;
	if(wiegandTimeout) wiegandTimeout--;

	TimeTick++;
	if (TimeTick >= 200)
	{
		TimeTick = 0;
		TCPClockHandler();
	}

	if(wiegandData0() && wiegandData1()) return;

}

void setupHardware(void)
{
    SysTick_Config(CGU_GetPCLKFrequency(CGU_PERIPHERAL_M4CORE)/1000);

    scu_pinmux(4 , 8, MD_PUP, FUNC4); 	// P8.1 : USB0_IND1 LED
	GPIO_SetDir(LED1_PORT,(1<<LED1_BIT), 1);
	GPIO_SetValue(LED1_PORT,(1<<LED1_BIT));

	RIT_Init(LPC_RITIMER);
	RIT_TimerConfig(LPC_RITIMER, 1);
	RIT_Cmd(LPC_RITIMER, ENABLE);

	ciaaUARTInit();

	ciaaInputInit();

	enetInit();
}

int main(void)
{

	setupHardware();

	dbgPrint("[main]CIAA Demo 1.0\n");

    cr_start_m0(SLAVE_M0APP,&__core_m0app_START__);

#if 0
    msec = 0;
    do
    {
    	uartRxDataCount=0;
		UARTPuts(LPC_USART3, "x");
		msec=500;
    	while(msec);
    }while(uartRxBuf[0]!='M');

    UARTPuts(LPC_USART3, ".");
#endif

	while(1)
	{
		webPeriodicalTask();

		wiegandReaderTask();
#if 0
		if(msec==0)
		{
			uartRxDataCount=0;
			UARTPuts(LPC_USART3, "s");
			msec=1000;
		}

		if(uartRxDataCount && (uartRxBuf[0]=='N'))
			uartRxDataCount=0;
		if(uartRxDataCount==8)
		{
			dbNewUID((char *)uartRxBuf);
			uartRxDataCount=0;
		}
#endif
	}
}

void check_failed(uint8_t *file, uint32_t line)
{
	while(1);
}

